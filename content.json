{"meta":{"title":"skywarmer's blog","subtitle":"subtitle goes here","description":"description goes here","author":"wanghongsheng","url":"https://skywarmer.github.io"},"pages":[{"title":"About","date":"2016-09-12T06:22:57.000Z","updated":"2016-09-12T06:22:57.000Z","comments":true,"path":"about/index.html","permalink":"https://skywarmer.github.io/about/index.html","excerpt":"","text":""},{"title":"Categories","date":"2016-09-12T06:22:57.000Z","updated":"2016-09-12T06:22:57.000Z","comments":true,"path":"categories/index.html","permalink":"https://skywarmer.github.io/categories/index.html","excerpt":"","text":""},{"title":"Tags","date":"2016-09-12T06:22:57.000Z","updated":"2016-09-12T06:22:57.000Z","comments":true,"path":"tags/index.html","permalink":"https://skywarmer.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"fucking blocks syntax","slug":"fucking-blocks-syntax","date":"2016-09-16T16:46:30.000Z","updated":"2016-09-16T16:54:35.000Z","comments":true,"path":"2016/09/17/fucking-blocks-syntax/","link":"","permalink":"https://skywarmer.github.io/2016/09/17/fucking-blocks-syntax/","excerpt":"","text":"声明：内容来自http://fuckingblocksyntax.com/ How Do I Declare A Block in Objective-C?As a local variable:returnType (^blockName)(parameterTypes) = ^returnType(parameters) &#123;...&#125;; As a property:@property (nonatomic, copy, nullability) returnType (^blockName)(parameterTypes); As a method parameter:- (void)someMethodThatTakesABlock:(returnType (^nullability)(parameterTypes))blockName; As an argument to a method call:[someObject someMethodThatTakesABlock:^returnType (parameters) &#123;...&#125;]; As a typedef:typedef returnType (^TypeName)(parameterTypes);TypeName blockName = ^returnType(parameters) &#123;...&#125;;","categories":[{"name":"ios","slug":"ios","permalink":"https://skywarmer.github.io/categories/ios/"}],"tags":[],"keywords":[{"name":"ios","slug":"ios","permalink":"https://skywarmer.github.io/categories/ios/"}]},{"title":"clang命令","slug":"clang命令","date":"2016-09-16T12:40:04.000Z","updated":"2016-09-16T16:53:56.000Z","comments":true,"path":"2016/09/16/clang命令/","link":"","permalink":"https://skywarmer.github.io/2016/09/16/clang命令/","excerpt":"","text":"Wiki Clang /ˈklæŋ/ is a compiler front end for the programming languages C, C++, Objective-C, Objective-C++, OpenMP, OpenCL, and CUDA. It uses LLVM as its back end and has been part of the LLVM release cycle since LLVM 2.6. It is designed to be able to replace the full GNU Compiler Collection (GCC). Its contributors include Apple, Microsoft, Google, ARM, Sony, Intel and Advanced Micro Devices (AMD). It is open-source software, with source code released under the University of Illinois/NCSA License, a permissive free software licence. https://en.wikipedia.org/wiki/Clang LLVMLLVM 是 Low Level Virtual Machine （底层虚拟机）的简称，这个库提供了与编译器相关的支持，能够进行程序语言的编译期优化、链接优化、在线编译优化、代码生成。可以作为多种语言编译器的后台来使用。 clang -rewrite-objcclang -rewrite-objc 的作用是把 oc 代码转写成 c/c++ 代码，推测 OC 底层的实现原理。 使用方法clang -rewrite-objc &lt;Objective-C source file&gt; 比如，在 OC 中，方法调用又称为消息发送，但消息发送是怎么实现的呢？ - (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. Person *p = [Person new]; [p foo];&#125; 在终端输入 clang -rewrite-objc ViewController.m 在生成的 ViewController.cpp 文件中，可以找到 ViewDidLoad 方法改写后的实现： static void _I_ViewController_viewDidLoad(ViewController * self, SEL _cmd) &#123; ((void (*)(__rw_objc_super *, SEL))(void *)objc_msgSendSuper)((__rw_objc_super)&#123;(id)self, (id)class_getSuperclass(objc_getClass(&quot;ViewController&quot;))&#125;, sel_registerName(&quot;viewDidLoad&quot;)); Person *p = ((Person *(*)(id, SEL))(void *)objc_msgSend)((id)objc_getClass(&quot;Person&quot;), sel_registerName(&quot;new&quot;)); ((void (*)(id, SEL))(void *)objc_msgSend)((id)p, sel_registerName(&quot;foo&quot;));&#125; 也就是说 [p foo] 在动态编译的时候，会被转意为： objc_msgSend(p, sel_registerName(&quot;foo&quot;));。 指定SDKOC 代码转写成 C/C++ 代码时，在模拟器和真机上，有时候是有区别的。如果需要指定 SDK ，那么要结合xcrun命令。 真机： xcrun -sdk iphoneos[ver] clang -rewrite-objc &lt;inputs&gt; 模拟器：xcrun -sdk iphonesimulator[ver] clang -rewrite-objc &lt;inputs&gt; 可通过 xcodebuild -showsdks 来查看机器上的 SDK OS X SDKs: OS X 10.11 -sdk macosx10.11iOS SDKs: iOS 9.3 -sdk iphoneos9.3iOS Simulator SDKs: Simulator - iOS 9.3 -sdk iphonesimulator9.3tvOS SDKs: tvOS 9.2 -sdk appletvos9.2tvOS Simulator SDKs: Simulator - tvOS 9.2 -sdk appletvsimulator9.2watchOS SDKs: watchOS 2.2 -sdk watchos2.2watchOS Simulator SDKs: Simulator - watchOS 2.2 -sdk watchsimulator2.2 指定 framework如果使用了iOS frameworks，（如UIKit） 或者 第三方 SDK （如听云），执行clang -rewrite-objc的时候会提示错误:ViewController.h:9:9: fatal error: &apos;UIKit/UIKit.h&apos; file not found#import &lt;UIKit/UIKit.h&gt; ^1 error generated. 这是因为没有引入 framework，clang 不知道去哪里找，需要用 -F 选项指定 要引入的 framework。 clang -rewrite-objc -F UIKit &lt;inputs&gt; 如果指定了 sdk，则不需要指定 iOS 内部 frameworks ``` 之前在读 Apple 开源的 runtime 源码的时候，经常使用这个命令，就起了个简短的别名，方便使用： 在~/.bashrc 或者 ~/.zshrc（for zsh 用户）中添加一行 alias deoc=&quot;xcrun -sdk iphonesimulator9.3 clang -rewrite-objc&quot;。（请先使用xcodebuild -showsdks` 查看自己电脑上的 sdk 做相应修改） 保存，退出；打开一个新窗口，或者在当前窗口运行 source ~/.bashrc（for bash users） 或者 source ~/.zshrc (for zsh users) 现在开始，使用 deoc 来代替 xcrun -sdk iphonesimulator9.3 clang -rewrite-objc ，后面接 OC 源文件 （和 -F framework，如果需要引入第三方 sdk）。 关于clang的更多使用方法，请参考: objc 中国-编译器 man clang Refrences: clang -rewrite-objc的使用点滴","categories":[{"name":"ios","slug":"ios","permalink":"https://skywarmer.github.io/categories/ios/"}],"tags":[],"keywords":[{"name":"ios","slug":"ios","permalink":"https://skywarmer.github.io/categories/ios/"}]},{"title":"Core Data","slug":"Core-Data","date":"2016-09-12T15:06:37.000Z","updated":"2016-09-16T16:54:16.000Z","comments":true,"path":"2016/09/12/Core-Data/","link":"","permalink":"https://skywarmer.github.io/2016/09/12/Core-Data/","excerpt":"","text":"Core DataCore Data StackManaged Object Model - It describs the schema that you use in the app. In Xcode, the Managed Object Model is defined in a file with the extension .xcdatamodeld. You can use the visual editor to define the entities and their attributes, as well as, relationships. Persistant Store Coordinator - SQLite is the default persistant store in iOS. However Core Data allows developers to setup multiple stores containing different entities. The Persistant Store Coordinator is the party responsible to manage different persistant object stores and save th objects to the stores. Forget about it you don’t understand what it is. You’ll not interact with Persistant Store Coordinator directly when using Core Data. Managed Object Context - Think of it as a “scratch pad” containing objects that interacts with data in persistent store. Its job is to manage objects created and returned using Core Data. Among the components in the Core Data Stack, the Managed Object Context is the one you’ll work with for most of the time. In general, whenever you need to fetch and save objects in persistent store, the context is the first component you’ll talk to. The below illustration can probably give you a better idea about the Core Data Stack","categories":[{"name":"ios","slug":"ios","permalink":"https://skywarmer.github.io/categories/ios/"}],"tags":[],"keywords":[{"name":"ios","slug":"ios","permalink":"https://skywarmer.github.io/categories/ios/"}]},{"title":"将命令行输出放在剪切板上","slug":"将命令行输出放在剪切板上","date":"2016-09-12T03:15:06.000Z","updated":"2016-09-16T16:43:24.000Z","comments":true,"path":"2016/09/12/将命令行输出放在剪切板上/","link":"","permalink":"https://skywarmer.github.io/2016/09/12/将命令行输出放在剪切板上/","excerpt":"","text":"为什么要这么做？ 直接把命令的输出（比如grep/awk/sed/find或是你的程序输出结果）放到剪切板上，这么就可以在IM中CTRL + V粘贴后发出去。 避免操作的繁琐和跳跃：把结果输出到文件、用文本编辑器打开文件、选中文本、CTRL + C。 通过命令将文件内容拷贝到剪切板，以避免拷贝错误、操作的跳跃（跳到文件编辑器） Windows下 使用系统自带的clip命令。 位于C:\\Windows\\system32\\clip.exe。示例： $ echo Hello | clip #将字符串Hello放入Windows剪贴板$ dir | clip #将dir命令的输出放入Windows剪切板$ clip &lt; README.TXT #将README.TXT的文本放入Windows剪切板$ echo | clip # 将一个空行放入Windows剪切板，即清空Windows剪切板 Linux下 使用xsel命令。 参见笔记:How do I pipe terminal standard output (stdout) to the clipboard? 示例： $ cat README.TXT | xsel #将输出放在剪切板$ cat README.TXT | xsel -b # 如有问题，可以试试-b选项$ xsel &lt; README.TXT # 将readme.txt的文本放入剪贴板$ xsel -c # 清空剪贴板 Mac下 使用 pbcopy 命令。 # 对应有个pbpaste命令。 示例： $ echo ‘Hello World!’ | pbcopy #将字符串“Hello World！”放入剪切板$ pbpaste #将剪切板中内容输出到终端","categories":[{"name":"ios","slug":"ios","permalink":"https://skywarmer.github.io/categories/ios/"}],"tags":[],"keywords":[{"name":"ios","slug":"ios","permalink":"https://skywarmer.github.io/categories/ios/"}]}]}